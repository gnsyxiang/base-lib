socket
======





## 问题

### 客户端和服务端到底哪个先退出？这个有什么区别？（死循环）

* 启动顺序是确定的

服务器首先启动，bind处于祯听状态（祯听连接的客户端的个数），
accept接受来自客户端的数据请求，然后对数据进行处理，并把数据返回给客户端。

* 先退出服务端

当先退出服务器时（ctrl + c），客户端不会立即退出，当在发送一次数据便会自动退出。
这是因为在正常通信中，服务器关闭了连接，那么客户端会正常接收到EOF，，如果对这个连接用epoll或者select进行监听，可以马上得知服务器关闭了连接。否则就定时向服务器发心跳探测，不然是不太可能得知服务器目前的状态的。之所以你现在不会立刻发现问题是因为服务器退出后，客户端需要靠下一次send才会触发问题，因为这时候连接已关闭，而客户端继续写，会产生SIGPIPE异常，而这个异常的默认动作是进程终止，所以你的客户端退出了。

* 先退出客户端

当先退出客户端时（ctrl + c），服务端进入死循环，一直有信息打印
当我们关闭客户端后，客户端会发送一个数据（EOF，也就是-1），然后服务端通过read（）函数收到这个数据，
知道了客户端已经退出，所以服务端也就推出了程序，并且调用相应的close操作。

> note: 当客户端结束后，服务端read（）函数返回的应该是0,而不是-1

### 为什么有的时候`bind：address already in use`一直存在？不是说好的2-4分钟吗，（ctrl + z 和 ctrl + c）

* 使用`ctrl+c`

CTRL+C：发送SIGINT信号给前台进程组中的所有进程。常用于终止正在运行的程序，强制中断程序的执行

通过下面的命令可以看到指定端口出现了`TIME_WAIT`
```sh
netstat -an | ag 8887
```
当重新运行程序时，就会出现`bind：address already in use`

但是，当我们等上个2-4分钟后，然后在运行，就又没有这种情况了，很好解释，那只是因为在一定的时间内这个端口还被占用着，没有来的及释放，但是2-4分钟后，端口释放完毕，所以可以正常的运行这个程序了

* 使用`ctrl + z`
CTRL+Z：发送SIGTSTP信号给前台进程组中的所有进程，常用于挂起一个进程，是将任务中断，
        但是此任务并没有结束，它仍然在进程中他只是维持挂起的状态，
		用户可以使用fg/bg操作继续前台或后台的任务，fg命令重新启动前台被中断的任务，
		bg命令把被中断的任务放在后台执行

同样的：我们可以看到右下角：出现的是ESTABLISHED，但是不一样的是，无论我们等多久，只要我们一运行这个服务端程序，必定会出现bind：address already in use，并且这个不会自动消失，除非我们杀死这个进程，或者我们进到程序里面改一下端口号

ESTABLISHED的意思是建立连接。表示两台机器正在通信。
TIME_WAIT：我方主动调用close()断开连接，收到对方确认后状态变为TIME_WAIT。TCP协议规定TIME_WAIT状态会一直持续2MSL(即两倍的分 段最大生存期)，以此来确保旧的连接状态不会对新连接产生影响。处于TIME_WAIT状态的连接占用的资源不会被内核释放，所以作为服务器，在可能的情 况下，尽量不要主动断开连接，以减少TIME_WAIT状态造成的资源浪费。目前有一种避免TIME_WAIT资源浪费的方法，就是关闭socket的LINGER选项。但这种做法是TCP协议不推荐使用的，在某些情况下这个操作可能会带来错误


### 当`bind：address already in use`不是一直存在时（存在2-4分钟时），如何避免？

当我们用：setsockopt和SO_REUSEADDR时：充分的减少了等待时间，在一次的通讯完毕，可以直接再次的运行这个程序，这样就不会出现上面如：bind：address already in use
程序如下（在bind之前调用，提高端口的重用行）：

可以看到我们可以直接运行，无压力，但是当我们用：netstat -an|grep TIME_WAIT时，还是显示TIME_WAIT，但这个并不影响我们的结果

```c
int val = 1;
int ret = setsockopt(sfd,SOL_SOCKET,SO_REUSEADDR,(void *)&val,sizeof(int));
```



